<html>
<head>  
   <link rel="stylesheet" type="text/css" href="resource/css/style.css">
   <meta charset="ISO-8859-1">
   <title>Insert title here</title>
   <script src="https://maps.googleapis.com/maps/api/js?callback=initMap" 
              async defer></script><!-- &key=AIzaSyC_IEs6_W9MDGagKWO6ABTzAqJm0O5AyNQ-->   
</head>
<body>
<div>
    <br>  
  <div class="map" id="map">
   map goes here.
  </div>  
  <div class="div-color">
      <div class="color-box" id="mood-div" style="background-color: RGB(127,127,127)">Current Tweet Mood</div>
  </div>
  <div class="div-color">
      <div class="color-box2" id="globalMood-div" style="background-color: RGB(127,127,127)">Average Tweet Mood</div>
  </div>
    <br><br>        
  <div id='button-div' style='display: none'>
       <button type="button" id="stop-btn" name='stop-btn' onclick="buttonHandler(this)" 
         method="post">Pause Streaming</button>
      Note: You can always pause your streaming, change the parameters in your form, then click 'Resume Streaming'. 
      This will show you your new results on top of the current map.
      <br><br>          
       <button type="button" id="circle-btn" name='circle-btn' onclick="buttonHandler(this)" 
         method="post">Show Hidden Circles</button>                
  </div>  
    <br><br>      
  <textarea name="text" id="text1" cols="150" rows="10">
      Live streaming tweets...
  </textarea>   
</div>
  <br>

<!-- Note the use of a button rather than input to submit form; prevents
page refresh, to preserve utility of ajax-->
<div class="form central" id="form-input">
   <form id="form">
     <fieldset>
       <legend>Your guidelines:</legend>
          What subject do you want to follow?<br>
       <input type="text" id="subject" value="DonaldTrump"><br>
         Define a coordinate bounding box for your search. The default box is all of continental US. <br>
       <input type="text" id="location" value="'-124.47,24.0,-66.56,49.3843'"><br>
         When do you want your viewing to start? <br>
       <input type="text" id="startdate" ><br>
         When do you want your viewing to end? <br>
       <input type="text" id="enddate" ><br>
         What time step would you like to set between data points? <br>
       <input type="text" id="timestep" ><br>
           Select units for the time step.   
      <select name="timeUnits" form="form-input" id="timeunits">
         <option value="seconds">Seconds</option>
         <option value="minutes">Minutes</option>
         <option value="hours">Hours</option>
         <option value="days">Days</option>
      </select>
       <br><br>
       <button type="button" id="submit-btn" onclick="buttonHandler(this)" name='submit-btn' style='display: block'
         method="post">Submit</button>  
     </fieldset>
   </form>
</div>   


<script type="text/javascript">

  var hiddenMarks = []; 
  var xhr = new XMLHttpRequest();
  var globalMood = {"mood" : [0,0,0],
                    "count" : 1 };
  var geoCoder;
  var map;       

  function buttonHandler(source){
    var name = source.name;
    switch (name){
      case 'submit-btn':
        toggle(document.getElementById('button-div').style, 'display', 'none', 'block', ajaxFormSubmit);
        toggle(document.getElementById('submit-btn').style, 'display', 'block', 'none');
        break;
      case 'stop-btn':
        toggle(document.getElementById('stop-btn').firstChild, 'data', 'Resume Streaming', 'Pause Streaming', ajaxFormSubmit,  ajaxPauseStream);
        break;        
      case 'circle-btn':
        showHidden();
        break;
    }

    // Callbacks are optional -- if ommitted, the action will only toggle an element's property; if included, will also invoke callback.
    function toggle(elem, prop, oldValue, newValue, callback1, callback2){
      elem[prop] == oldValue ? action(newValue, callback1) : action(oldValue, callback2); 
      function action(value, callback){
          elem[prop] = value;
        if (callback != undefined){        
          callback();
        }
      }
    }

    function showHidden(){
      alert("showHidden fired. Length of enclosed array is: " + hiddenMarks.length)
      hiddenMarks.forEach(function(mark){
        alert(mark)
        mark.setMap(map);
      });
    }    
  }
//})();

  function ajaxPauseStream(){
    
    // Abort should be sufficient. The request below is a fail safe measure to ensure twitter streaming stops.
    xhr.abort();
        
    var pauseXhr = new XMLHttpRequest();
    var response = {};

    pauseXhr.open('POST','../pauseStream', true);
     // Needed for the POST form data request
    pauseXhr.setRequestHeader('Content-Type','text/plain');
      // Send the request
    pauseXhr.send();

    pauseXhr.onreadystatechange = function(){
      if (this.readyState === XMLHttpRequest.DONE){
        if (this.status === 200) {
          document.getElementById("text1").value = 'Streaming paused \n\n' + document.getElementById("text1").value;
        } else {
          alert('There was a problem with the request.')
        }
      }
    };         
  }

  function ajaxFormSubmit(){
    
    sendData(serializeJson(jsonifyForm()));

    (function toggleButtonDisplay(buttonStyle){
      if (buttonStyle.display == 'none'){
        buttonStyle = 'block';
      }
    })(document.getElementById('stop-btn').style)

    function jsonifyForm(){
      var data = { subject: document.getElementById("subject").value,
                   locations : document.getElementById("location").value,
                   tart : document.getElementById("startdate").value,
                   end : document.getElementById("enddate").value,
                   step : document.getElementById("timestep").value,
                   units : document.getElementById("timeunits").value 
                  }
      return data;
    }    

    function serializeJson(json){

      var urlEncodedData = "";
      var urlEncodedDataPairs = [];
      var name; 

      for (name in json){
         urlEncodedDataPairs.push(encodeURIComponent(name) + '=' + encodeURIComponent(json[name]));
      }
      return urlEncodedDataPairs.join('&').replace(/%20/g, '+');
    }

    function sendData(data){

      // Set the request
      xhr.open('POST','../twitterQuery', true);

      // Needed for the POST form data request
      xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded');

      // Send the data
      xhr.send(data);

      xhr.onreadystatechange = function (){

        if (this.readyState === XMLHttpRequest.LOADING ||
            this.readyState === XMLHttpRequest.DONE){
            if (this.status === 200) {
              var responseJSON = parseResponse(this.responseText);
            } else {
              // alert('There was a problem with the request.')
            }
        }

        function parseResponse(response){

          var jsonTweet = JSON.parse(response.substring(response.lastIndexOf('{"text":"'), response.length));
          displayText(document.getElementById('text1'));
          updateMoodBox(document.getElementById('mood-div'), jsonTweet.stats.mood);
          updateAverageMoodBox(jsonTweet.stats.mood);
          geoCodeTweet(jsonTweet);
          return jsonTweet;

          function displayText(html){
            html.value = (html.value + '\n\n' + jsonTweet.text + '\n\n' + ' . .  .   .  . .  .   .  . .');
          }
         
          function updateMoodBox(html, mood){
            mood = mood.toString();
            html.style = 'background-color: RGB(' + mood + ')';  
          }
          
          function updateAverageMoodBox(mood){
            var RGB = [];
            if (mood.length === globalMood["mood"].length){
              mood.forEach(function(value, i){
                globalMood.mood[i] += Number(value);
                RGB[i] = (globalMood.mood[i] / globalMood.count).toFixed(0);
              }) 
            } else {
              alert("Error: This tweet's color array is incorrectly formatted.")
            }
            updateMoodBox(document.getElementById('globalMood-div'), RGB);
            globalMood.count++;
          }

          function geoCodeTweet(tweet){
            var location = tweet.location;
            var center = null;

            if (location != null){
              var id = location.substring(0,3);
              location = location.substring(3,location.length);
              tweet.location = location;
              switch(id){
                case 'CO:':
                  alert("~~~~ CO FOUND")
                  var latLng = location.split(",");
                  center.lat = Number(latLng[0]);
                  center.lng = Number(latLng[1]);
                  break;
                case 'ST':
                  // the UL code should work just as well for street names; allow to continue through to UL caes.
                case 'UL:':
                  geoCoder.geocode({'address':location}, function(results, status){
                    if (status == google.maps.GeocoderStatus.OK){
                      if (results != null){
                        if (results[0].geometry != null && results[0].geometry.location != null){
                          center = results[0].geometry.location;
                          //center = {'lat': loc.lat(), 'lng': loc.lng()};
                          drawTweetCircle(tweet, center);
                        }
                      }
                    }  
                  });               
                  break;
                default:    
              }
            } else if (location == null || center == null){
            // The middle of Iceland, for non-located tweets!
              center = {'lat': 77.113132, 'lng': -42.539063};
              drawTweetCircle(tweet, center);   
            }  
          }

          function drawTweetCircle(tweet, center){
            var stats = tweet.stats;
            var color = 'RGB(' + stats.mood.toString() + ')';
            var radius = tweet.stats.reach;
            if (radius == undefined){
              radius = 25;
            } else {
              radius *= 25;
            }
            var cityCircle = new google.maps.Circle({
              'strokeColor'  : color,
              'strokeOpacity': .8,
              'strokeWeight' : 2,
              'fillColor'    : color,
              'fillOpacity'  : .35, 
              'map'          : map,
              'center'       : center,
              'radius'       : radius,
              'draggable'    : true,
              'clickable'    : true,
            });

            var content = "User: " + tweet.name + "\nText: " + tweet.text + "\nLocation: " + tweet.location + "\nMood: " + tweet.stats.mood + "\nReach: " + tweet.stats.reach;
            var infoWindow = new google.maps.InfoWindow({
              'content'  : content,
              'maxWidth' : 250,
              'position' : cityCircle.center,
            });

/*
            cityCircle.addListener('click', function(){
                infoWindow.position = this.center;
                infoWindow.open(map);              
            })
*/           
            cityCircle.addListener('mouseover', function(){

              infoWindow.position = this.center;
              infoWindow.open(map);
            });
 
            cityCircle.addListener('mouseout', function(){
              infoWindow.close(map);
            });

            cityCircle.addListener('dblclick', function(){
              infoWindow.setMap(null);
              this.setMap(null);
              hiddenMarks.push([this, infoWindow]);
            });            

            cityCircle.addListener('drag', function(){
              infoWindow.setMap(null);
            });

            cityCircle.addListener('dragend', function(){
              this.setMap(map);
              infoWindow.position = this.center;
              infoWindow.setMap(map);
            });
          }          
        }
      }         
    }
  }

  function initMap(){

    var mapProps = {
      'streetViewControl'      : false,
      'disableDoubleClickZoom' : true,      
      'center'                 : new google.maps.LatLng(42.877742, -97.380979),
      'zoom'                   : 4,
      'minZoom'                : 2,
      'maxZoom'                : 12,
      'mapTypeId'              : [google.maps.MapTypeId.ROADMAP, 'map_style'],
    };

    // Styles from the fantastic Google Styled Maps Wizard, http://googlemaps.github.io/js-samples/styledmaps/wizard/index.html
    var mapStyles = [
      {
        "featureType": "road",
        "stylers": [
          { "visibility": "off" }
        ]
      },{
        "featureType": "poi",
        "stylers": [
          { "visibility": "off" }
        ]
      },{
        "featureType": "transit",
        "stylers": [
          { "visibility": "off" }
        ]
      },{
        "elementType": "labels",
        "stylers": [
          { "lightness": 49 }
        ]
      },{
        "featureType": "administrative",
        "elementType": "geometry.fill",
        "stylers": [
          { "visibility": "off" }
        ]
      },{
        "featureType": "administrative",
        "elementType": "geometry.stroke",
        "stylers": [
          { "lightness": 48 }
        ]
      },{
      }
    ];
    var styledMap = new google.maps.StyledMapType(mapStyles, {name: 'Styled Map'});
    geoCoder = new google.maps.Geocoder();
    map = new google.maps.Map(document.getElementById('map'), mapProps);
    map.mapTypes.set('map_style', styledMap);
    map.setMapTypeId('map_style');
    alert(typeof map)
    alert(JSON.stringify(map));
  }

</script>
</body>
</html>



